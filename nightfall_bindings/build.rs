use alloy::primitives::keccak256;
use log::info;
use serde::Deserialize;
use std::{
    env, fmt::Write, fs, os::unix::process::ExitStatusExt, path::Path, path::PathBuf,
    process::Command,
};
#[derive(Deserialize)]
struct BytecodeObj {
    object: String,
}

#[derive(Deserialize)]
struct Artifact {
    #[serde(rename = "deployedBytecode")]
    deployed_bytecode: BytecodeObj,
}

fn load_runtime_code_hex(path: &PathBuf) -> String {
    let data = fs::read_to_string(path)
        .unwrap_or_else(|e| panic!("Failed to read artifact {path:?}: {e}"));
    let artifact: Artifact =
        serde_json::from_str(&data).unwrap_or_else(|e| panic!("Bad artifact JSON {path:?}: {e}"));
    let mut hex = artifact.deployed_bytecode.object;
    if let Some(stripped) = hex.strip_prefix("0x") {
        hex = stripped.to_string();
    }
    hex
}

fn hex_to_bytes(hex: &str) -> Vec<u8> {
    if hex.len() % 2 != 0 {
        panic!("odd-length hex");
    }
    (0..hex.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&hex[i..i + 2], 16).expect("invalid hex"))
        .collect()
}

fn write_const(out: &mut String, const_name: &str, bytes: &[u8; 32]) {
    write!(out, "pub const {const_name}: [u8; 32] = [").unwrap();
    for (i, b) in bytes.iter().enumerate() {
        if i != 0 {
            out.push_str(", ");
        }
        write!(out, "0x{b:02x}").unwrap();
    }
    out.push_str("];\n");
}

fn main() {
    // Find repo root: nightfall_bindings/.. is repo root
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let repo_root = manifest_dir.parent().unwrap().to_path_buf();

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let dest = out_dir.join("code_hashes.rs");

    let mut contents = String::from("// Auto-generated by build.rs â€” DO NOT EDIT\n");

    info!("Building the artifacts");
    // Run forge build
    forge_command(&["build"]);
    // read the artifacts.rs and replace the dummy_artifact with artifacts
    let artifacts_path = Path::new("../nightfall_bindings/src/artifacts.rs");
    if artifacts_path.exists() {
        info!("Artifacts file found at {artifacts_path:?}");
        let content =
            std::fs::read_to_string(artifacts_path).expect("Failed to read artifacts.rs file");
        let updated_content = content.replace("dummy_artifacts", "artifacts");
        std::fs::write(artifacts_path, updated_content)
            .expect("Failed to write updated artifacts.rs file");
    } else {
        panic!("Artifacts file not found at {artifacts_path:?}");
    }

    // ---------- NIGHTFALL ----------
    let nightfall_artifact =
        repo_root.join("blockchain_assets/artifacts/Nightfall.sol/Nightfall.json");
    let nf_hex = load_runtime_code_hex(&nightfall_artifact);
    let nf_bytes = hex_to_bytes(&nf_hex);
    let nf_hash = keccak256(&nf_bytes);
    write_const(&mut contents, "NIGHTFALL_IMPL_HASH_BYTES", &nf_hash.0);

    // ---------- ROUND ROBIN ----------
    let rr_artifact = repo_root.join("blockchain_assets/artifacts/RoundRobin.sol/RoundRobin.json");
    let rr_hex = load_runtime_code_hex(&rr_artifact);
    let rr_bytes = hex_to_bytes(&rr_hex);
    let rr_hash = keccak256(&rr_bytes);
    write_const(&mut contents, "ROUND_ROBIN_IMPL_HASH_BYTES", &rr_hash.0);

    // ---------- X509 ----------
    let x509_artifact = repo_root.join("blockchain_assets/artifacts/X509.sol/X509.json");
    let x509_hex = load_runtime_code_hex(&x509_artifact);
    let x509_bytes = hex_to_bytes(&x509_hex);
    let x509_hash = keccak256(&x509_bytes);
    write_const(&mut contents, "X509_IMPL_HASH_BYTES", &x509_hash.0);

    fs::write(&dest, contents).expect("failed to write code_hashes.rs");

    println!("cargo:rerun-if-changed={}", nightfall_artifact.display());
    println!("cargo:rerun-if-changed={}", rr_artifact.display());
    println!("cargo:rerun-if-changed={}", x509_artifact.display());
}

/// Function should only be called after we have checked forge is installed by running 'which forge'
fn forge_command(command: &[&str]) {
    let output = Command::new("forge").args(command).output();

    match output {
        Ok(o) => {
            if o.status.success() {
                info!(
                    "Command 'forge {:?}' executed successfully: {}",
                    command,
                    String::from_utf8_lossy(&o.stdout)
                );
            } else {
                panic!(
                "Command 'forge {:?}' executed with failing error code: {:?}\nStandard Output: {}\nStandard Error: {}",
                command,
                o.status.signal(),
                String::from_utf8_lossy(&o.stdout),
                String::from_utf8_lossy(&o.stderr)
            );
            }
        }
        Err(e) => {
            panic!("Command 'forge {command:?}' ran into an error without executing: {e}");
        }
    }
}
