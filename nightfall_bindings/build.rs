use alloy::primitives::keccak256;
use log::info;
use serde::Deserialize;
use std::{
    env, fmt::Write, fs, os::unix::process::ExitStatusExt, path::Path, path::PathBuf,
    process::Command,
};
#[derive(Deserialize)]
struct BytecodeObj {
    object: String,
}

#[derive(Deserialize)]
struct Artifact {
    #[serde(rename = "deployedBytecode")]
    deployed_bytecode: BytecodeObj,
}

fn load_runtime_code_hex(path: &PathBuf) -> String {
    let data = fs::read_to_string(path)
        .unwrap_or_else(|e| panic!("Failed to read artifact {path:?}: {e}"));
    let artifact: Artifact =
        serde_json::from_str(&data).unwrap_or_else(|e| panic!("Bad artifact JSON {path:?}: {e}"));
    let mut hex = artifact.deployed_bytecode.object;
    if let Some(stripped) = hex.strip_prefix("0x") {
        hex = stripped.to_string();
    }
    hex
}

fn hex_to_bytes(hex: &str) -> Vec<u8> {
    if hex.len() % 2 != 0 {
        panic!("odd-length hex");
    }
    (0..hex.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&hex[i..i + 2], 16).expect("invalid hex"))
        .collect()
}

fn write_const(out: &mut String, const_name: &str, bytes: &[u8; 32]) {
    write!(out, "pub const {const_name}: [u8; 32] = [").unwrap();
    for (i, b) in bytes.iter().enumerate() {
        if i != 0 {
            out.push_str(", ");
        }
        write!(out, "0x{b:02x}").unwrap();
    }
    out.push_str("];\n");
}

fn strip_metadata_and_hash(bytecode: &[u8]) -> [u8; 32] {
    // Solidity metadata is at the end: 0xa2 0x64 'i' 'p' 'f' 's' 0x58 0x22 <32-byte-hash> 0x64 's' 'o' 'l' 'c' 0x43 <version> 0x00 0x33
    // Look for the metadata marker: 0xa264697066735822 (a2 64 "ipfs" 58 22)
    const METADATA_MARKER: [u8; 8] = [0xa2, 0x64, 0x69, 0x70, 0x66, 0x73, 0x58, 0x22];
    
    // Find the last occurrence of the metadata marker
    if let Some(pos) = bytecode.windows(METADATA_MARKER.len())
        .rposition(|window| window == METADATA_MARKER) {
        // Strip everything from the metadata marker onwards
        let stripped = &bytecode[..pos];
        println!("cargo:warning=Stripped {} bytes of metadata (original: {}, stripped: {})", 
                 bytecode.len() - stripped.len(), bytecode.len(), stripped.len());
        keccak256(stripped).0
    } else {
        println!("cargo:warning=No metadata marker found, using full bytecode");
        keccak256(bytecode).0
    }
}

fn main() {
    // Find repo root: nightfall_bindings/.. is repo root
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let repo_root = manifest_dir.parent().unwrap().to_path_buf();

    // Write directly into src/code_hashes.rs so lib.rs can include it
    let dest = manifest_dir.join("src/code_hashes.rs");

    let mut contents = String::from("// Auto-generated by build.rs â€” DO NOT EDIT\n");

    info!("Building the artifacts");
    // Run forge build
    forge_command(&["build"]);
    // read the artifacts.rs and replace the dummy_artifact with artifacts
    let artifacts_path = Path::new("../nightfall_bindings/src/artifacts.rs");
    if artifacts_path.exists() {
        info!("Artifacts file found at {artifacts_path:?}");
        let content =
            std::fs::read_to_string(artifacts_path).expect("Failed to read artifacts.rs file");
        let updated_content = content.replace("dummy_artifacts", "artifacts");
        std::fs::write(artifacts_path, updated_content)
            .expect("Failed to write updated artifacts.rs file");
    } else {
        panic!("Artifacts file not found at {artifacts_path:?}");
    }

    // ---------- NIGHTFALL ----------
    let nightfall_artifact =
        repo_root.join("blockchain_assets/artifacts/Nightfall.sol/Nightfall.json");
    // print the path being used
    println!(
        "cargo:warning=Using Nightfall artifact at path: {:?}",
        nightfall_artifact
    );   
    let nf_hex = load_runtime_code_hex(&nightfall_artifact);
    let nf_bytes = hex_to_bytes(&nf_hex);
    println!("cargo:warning=Nightfall runtime bytecode len: {:?}", nf_bytes.len());
    // println!("cargo:warning=Nightfall runtime nf_hex: {:?}", nf_hex);
    let nf_hash = strip_metadata_and_hash(&nf_bytes);
    println!("cargo:warning=Nightfall runtime bytecode hash 1: {:?}", nf_hash);
    let nf_hash = keccak256(&nf_bytes);
    println!("cargo:warning=Nightfall runtime bytecode hash 2: {:?}", nf_hash.0);
    write_const(&mut contents, "NIGHTFALL_IMPL_HASH_BYTES", &nf_hash.0);

    // ---------- ROUND ROBIN ----------
    let rr_artifact = repo_root.join("blockchain_assets/artifacts/RoundRobin.sol/RoundRobin.json");
    let rr_hex = load_runtime_code_hex(&rr_artifact);
    let rr_bytes = hex_to_bytes(&rr_hex);
    // println!("cargo:warning=RoundRobin runtime bytecode: {:?}", rr_bytes);
    let rr_hash = keccak256(&rr_bytes);
    write_const(&mut contents, "ROUND_ROBIN_IMPL_HASH_BYTES", &rr_hash.0);

    // ---------- X509 ----------
    let x509_artifact = repo_root.join("blockchain_assets/artifacts/X509.sol/X509.json");
    let x509_hex = load_runtime_code_hex(&x509_artifact);
    let x509_bytes = hex_to_bytes(&x509_hex);
    // println!("cargo:warning=X509 runtime bytecode: {:?}", x509_bytes);
    let x509_hash = keccak256(&x509_bytes);
    write_const(&mut contents, "X509_IMPL_HASH_BYTES", &x509_hash.0);

    fs::write(&dest, contents).expect("failed to write code_hashes.rs");

    println!("cargo:rerun-if-changed={}", nightfall_artifact.display());
    println!("cargo:rerun-if-changed={}", rr_artifact.display());
    println!("cargo:rerun-if-changed={}", x509_artifact.display());
}

/// Function should only be called after we have checked forge is installed by running 'which forge'
fn forge_command(command: &[&str]) {
    let output = Command::new("forge").args(command).output();

    match output {
        Ok(o) => {
            if o.status.success() {
                info!(
                    "Command 'forge {:?}' executed successfully: {}",
                    command,
                    String::from_utf8_lossy(&o.stdout)
                );
            } else {
                panic!(
                "Command 'forge {:?}' executed with failing error code: {:?}\nStandard Output: {}\nStandard Error: {}",
                command,
                o.status.signal(),
                String::from_utf8_lossy(&o.stdout),
                String::from_utf8_lossy(&o.stderr)
            );
            }
        }
        Err(e) => {
            panic!("Command 'forge {command:?}' ran into an error without executing: {e}");
        }
    }
}
